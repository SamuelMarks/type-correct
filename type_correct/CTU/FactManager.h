/**
 * @file FactManager.h
 * @brief Header for the Cross-Translation Unit Fact Management.
 *
 * Defines the logical structures for storing type usage facts and the
 * interfaces for serializing/deserializing these facts to intermediate files.
 * Includes support for iterative convergence checking and typedef root
 * propagation.
 *
 * @author SamuelMarks
 * @copyright CC0
 */

#ifndef TYPE_CORRECT_CTU_FACTMANAGER_H
#define TYPE_CORRECT_CTU_FACTMANAGER_H

#include <map>
#include <string>
#include <vector>

#include "type_correct_export.h"

namespace type_correct {
namespace ctu {

/**
 * @struct SymbolFact
 * @brief Represents a single data-type assertion about a specific symbol.
 *
 * This structure is used to serialize the state of the solver between
 * translation units. It captures the unique identifier of a symbol (Variable,
 * Function, or Typedef) and the "widest" type required by its usage context.
 */
struct SymbolFact {
  /**
   * @brief The Unified Symbol Reference (USR) generated by Clang.
   * Acts as a global unique key across translation units.
   */
  std::string USR;

  /**
   * @brief The string representation of the widest type found.
   * Examples: "size_t", "ptrdiff_t", "unsigned long".
   */
  std::string TypeName;

  /**
   * @brief Check if this symbol represents a field in a struct/class.
   * Fields often have stricter ABI constraints.
   */
  bool IsField;

  /**
   * @brief Check if this symbol represents a Typedef definition.
   * If true, this fact targets a "Root" type definition.
   */
  bool IsTypedef;

  /**
   * @brief Default constructor initializing fields to safe defaults.
   */
  SymbolFact() : IsField(false), IsTypedef(false) {}

  /**
   * @brief Parameterized constructor for easy instantiation.
   *
   * @param U The USR string.
   * @param T The Type name string.
   * @param F IsField flag.
   * @param TD IsTypedef flag.
   */
  SymbolFact(std::string U, std::string T, bool F, bool TD = false)
      : USR(std::move(U)), TypeName(std::move(T)), IsField(F), IsTypedef(TD) {}

  /**
   * @brief Equality operator for convergence checking.
   *
   * @param Other The other fact to compare against.
   * @return true if USR, TypeName, IsField, and IsTypedef are identical.
   */
  bool operator==(const SymbolFact &Other) const {
    return USR == Other.USR && TypeName == Other.TypeName &&
           IsField == Other.IsField && IsTypedef == Other.IsTypedef;
  }

  /**
   * @brief Inequality operator.
   *
   * @param Other The other fact.
   * @return true if any field differs.
   */
  bool operator!=(const SymbolFact &Other) const { return !(*this == Other); }
};

/**
 * @class FactManager
 * @brief Handles Serialization, Deserialization, and Merging of CTU facts.
 *
 * Provides functionality to:
 * 1. Write a list of observed facts from a single TU to a file (Map phase).
 * 2. Read facts from files (Reduce/Apply phase).
 * 3. Merge facts to determine the global winner for a symbol using a "widest
 * type wins" strategy.
 * 4. Check for convergence by comparing memory state to disk state to support
 * iterative solving.
 */
class TYPE_CORRECT_EXPORT FactManager {
public:
  /**
   * @brief Serialize a map of facts to a plain-text file.
   *
   * The file format is line-delimited: USR [TAB] TypeName [TAB] Flags.
   *
   * @param FilePath The output filesystem path.
   * @param Facts The map of USR -> SymbolFact to write.
   * @return true on successful write, false otherwise.
   */
  static bool WriteFacts(const std::string &FilePath,
                         const std::map<std::string, SymbolFact> &Facts);

  /**
   * @brief Deserialize facts from a file and append to the provided vector.
   *
   * @param FilePath The input filesystem path.
   * @param OutFacts Vector to populate with deserialized facts.
   * @return true on successful read, false if file missing or unreadable.
   */
  static bool ReadFacts(const std::string &FilePath,
                        std::vector<SymbolFact> &OutFacts);

  /**
   * @brief Reducing logic: Merges a raw list of facts into a unique map.
   *
   * Resolves conflicts by picking the "widest" type rank (e.g., size_t > int).
   * Supports specific logic for Typedef convergence.
   *
   * @param RawFacts List of all facts tied to diverse TUs.
   * @return std::map<std::string, SymbolFact> The consolidated global state.
   */
  static std::map<std::string, SymbolFact>
  MergeFacts(const std::vector<SymbolFact> &RawFacts);

  /**
   * @brief Compares a new set of merged facts against the existing global file.
   *
   * Used to determine if the iterative solver loop should terminate.
   *
   * @param GlobalFilePath The path to the existing global.facts file.
   * @param NewFacts The newly computed merged map.
   * @return true if the content of the file matches NewFacts exactly
   * (Converged).
   * @return false if the file is missing or content differs (Not Converged).
   */
  static bool
  IsConvergenceReached(const std::string &GlobalFilePath,
                       const std::map<std::string, SymbolFact> &NewFacts);
};

} // namespace ctu
} // namespace type_correct

#endif // TYPE_CORRECT_CTU_FACTMANAGER_H
