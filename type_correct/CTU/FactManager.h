/**
 * @file FactManager.h
 * @brief Header for the Cross-Translation Unit Fact Management.
 *
 * Defines the logical structures for storing type usage facts and the
 * interfaces for serializing/deserializing these facts to intermediate files.
 * Includes support for iterative convergence checking.
 *
 * @author SamuelMarks
 * @license CC0
 */

#ifndef TYPE_CORRECT_CTU_FACTMANAGER_H
#define TYPE_CORRECT_CTU_FACTMANAGER_H

#include <map>
#include <string>
#include <vector>

#include "type_correct_export.h"

namespace type_correct {
namespace ctu {

/**
 * @struct SymbolFact
 * @brief Represents a single type assertion about a specific symbol.
 */
struct SymbolFact {
  /** @brief The Unified Symbol Reference (USR) generated by Clang. */
  std::string USR;

  /** @brief The string representation of the widest type found (e.g.,
   * "size_t"). */
  std::string TypeName;

  /** @brief Whether this symbol is an ABI-affecting field. */
  bool IsField;

  /** @brief Default constructor. */
  SymbolFact() : IsField(false) {}

  /** @brief Parameterized constructor.
   *  @param U The USR string.
   *  @param T The Type name string.
   *  @param F IsField flag.
   */
  SymbolFact(std::string U, std::string T, bool F)
      : USR(std::move(U)), TypeName(std::move(T)), IsField(F) {}

  /**
   * @brief Equality operator for convergence checking.
   * @param Other The other fact to compare against.
   * @return true if USR, TypeName, and IsField are identical.
   */
  bool operator==(const SymbolFact &Other) const {
    return USR == Other.USR && TypeName == Other.TypeName &&
           IsField == Other.IsField;
  }

  /**
   * @brief Inequality operator.
   * @param Other The other fact.
   * @return true if any field differs.
   */
  bool operator!=(const SymbolFact &Other) const { return !(*this == Other); }
};

/**
 * @class FactManager
 * @brief Handles I/O for CTU facts.
 *
 * Provides functionality to:
 * 1. Write a list of observed facts from a single TU to a file.
 * 2. Read facts from files.
 * 3. Merge facts to determine the global winner for a symbol.
 * 4. Check for convergence by comparing memory state to disk state.
 */
class TYPE_CORRECT_EXPORT FactManager {
public:
  /**
   * @brief Serialize a map of facts to a file.
   *
   * @param FilePath The output path.
   * @param Facts The map of USR -> SymbolFact.
   * @return true on success.
   */
  static bool WriteFacts(const std::string &FilePath,
                         const std::map<std::string, SymbolFact> &Facts);

  /**
   * @brief Deserialize facts from a file and append to the provided map.
   *
   * @param FilePath The input path.
   * @param OutFacts Vector to populate with raw facts.
   * @return true on success.
   */
  static bool ReadFacts(const std::string &FilePath,
                        std::vector<SymbolFact> &OutFacts);

  /**
   * @brief Reducing logic: Merges a raw list of facts into a unique map.
   *
   * Resolves conflicts by picking the "widest" type.
   *
   * @param RawFacts List of all facts tied to diverse TUs.
   * @return std::map<std::string, SymbolFact> The consolidated global state.
   */
  static std::map<std::string, SymbolFact>
  MergeFacts(const std::vector<SymbolFact> &RawFacts);

  /**
   * @brief Compares a new set of merged facts against the existing global file.
   *
   * Used to determine if the iterative solver loop should terminate.
   *
   * @param GlobalFilePath The path to the existing global.facts file.
   * @param NewFacts The newly computed merged map.
   * @return true if the content of the file matches NewFacts exactly.
   * @return false if the file is missing or content differs.
   */
  static bool
  IsConvergenceReached(const std::string &GlobalFilePath,
                       const std::map<std::string, SymbolFact> &NewFacts);
};

} // namespace ctu
} // namespace type_correct

#endif // TYPE_CORRECT_CTU_FACTMANAGER_H